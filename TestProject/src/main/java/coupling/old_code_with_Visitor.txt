package main.java.coupling;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.VariableDeclarationExpr;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.github.javaparser.resolution.types.ResolvedType;
import com.github.javaparser.symbolsolver.JavaSymbolSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;
import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;
import com.github.javaparser.ast.nodeTypes.NodeWithVariables;
import com.github.javaparser.ast.Node;
import com.github.javaparser.resolution.UnsolvedSymbolException;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.symbolsolver.utils.SymbolSolverCollectionStrategy;
import com.github.javaparser.utils.ProjectRoot;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.utils.SourceRoot;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.expr.VariableDeclarationExpr;
import com.github.javaparser.ast.expr.LambdaExpr;
import com.google.errorprone.annotations.Var;
import com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.nio.file.Files;
import java.io.File;
import com.github.javaparser.StaticJavaParser;

public class Coupling
{




    private final CompilationUnit cu;
    private String content;
    private static CombinedTypeSolver typeSolver;
    //private List list = new ArrayList();
    //private Object a;

    public Coupling(CompilationUnit newCu, CombinedTypeSolver newTypeSolver)
    {
        typeSolver = newTypeSolver;
        //cType = VariableDeclarationExpr.class;
        //list.add("abc");
        //a = list.get(0);
        cu = newCu;
        content = cu.getChildNodes().toString();

        /*String[] str = new String[1];
        str[0] = "";
        try {
            test();
        } catch(Exception e) {}*/

        findFieldVarType(cu);
        findFieldVarType(cu);
        findVarType(cu);
        findMethodCallClass(cu);
        //printContent();
    }

    public static void test() throws IOException {
        System.out.println("1YOOOOOOOOOOOOOOOOO");

        //Parses stuff
        List<CompilationUnit> allCompilationUnits = new ArrayList<>();
        List list = new ArrayList();
        list.add("abc");
        Object a;
        a = list.get(0);


        String s1 = "C:\\Users\\geeth\\OneDrive\\Documents\\SQ proj\\SENG4430_Assigment\\TestProject\\src\\main\\java\\coupling\\Coupling.java"; //"src/test/java/Tree_TestData/src/main.java";

        /*Path root = Paths.get(s1);
        ProjectRoot projectRoot = new SymbolSolverCollectionStrategy().collect(root);
        System.out.println("1.5YOOOOOOOOOOOOOOOOO");
        SourceRoot sourceRoot = projectRoot.getSourceRoots().get(0);

        for(int i =0;i<projectRoot.getSourceRoots().size();i++) {

            SourceRoot sourceRoot = projectRoot.getSourceRoots().get(i);

            sourceRoot.tryToParse();

            List<CompilationUnit> compilationUnits = sourceRoot.getCompilationUnits();
            System.out.println("1.5YOOOOOOOOOOOOOOOOO");

            for(int j = 0;j<compilationUnits.size();j++) {

                allCompilationUnits.add(compilationUnits.get(j));
            }
        }
        CompilationUnit cu = allCompilationUnits.get(0);
        System.out.println("2YOOOOOOOOOOOOOOOOO");*/

        File file = new File(s1);
        CompilationUnit cu = StaticJavaParser.parse(file);

        //Start processing AST Tree
        NodeList<TypeDeclaration<?>> allTypes = cu.getTypes();
        NodeList<BodyDeclaration<?>> allMembers = allTypes.get(0).getMembers();

        //Finds method call through nodes in AST Tree
        //System.out.println("Method Call: "+allTypes.get(0).findAll(MethodCallExpr.class));

        //This is another way can find method call, through VoidVisitorAdaptor
        //Tho it gives you less control over the variables
        MethodCall mc = new MethodCall();
        mc.visit(cu,null);

        //Gets methods
        NodeList<BodyDeclaration<?>> allMethods = new NodeList<>();
        for(int i=0;i<allMembers.size();i++) {
            if(allMembers.get(i).isMethodDeclaration()) {
                allMethods.add(allMembers.get(i));

            }
        }

        //Gets a method
        MethodDeclaration aMethod = (MethodDeclaration) allMethods.get(7);

        //Gets variables in the method
        System.out.println("Variable Declaration in method: "+ aMethod.findAll(LambdaExpr.class));

        //Way 1: Find variable declarator through nodes
        List<LambdaExpr> variablesStuff = aMethod.findAll(LambdaExpr.class);
        /*int m = 1;
        for(Object o: allMethods)
        {
            System.out.println(m + ": " + o);
            m++;

        }*/

        /*
        Use ast/body/MethodDeclaration to get methods including 'List<VariableDeclarator> variablesStuff = aMethod.findAll(VariableDeclarator.class)' types
        Then get ast/expr/LambdaExpr to get [i ->...] values
        Where for every findAll method, it takes the parameter of that method, finds the class
        and matches the class's methods up with substrings containing '()' of lambdaExpr
         */
        System.out.println("//// " + variablesStuff.size());

        for(int i=0;i<variablesStuff.size();i++) {
            System.out.println("For variable "+variablesStuff.get(i));
            System.out.println("Param "+variablesStuff.get(i).getParameters());
            System.out.println("Resolving "+variablesStuff.get(i).getParameters().get(0).resolve().getName());
            System.out.println("Yo");/*
            System.out.println("Variable Name  is "+variablesStuff.get(i).resolve());
            System.out.println("Variable Class is "+variablesStuff.get(i).getType());
            System.out.println("Variable Initializer is"+variablesStuff.get(i).getInitializer());
            if(variablesStuff.get(i).getType().toString().contains("List"))
            {
                List listing = variablesStuff.get(i);
                for(Object o: listing)
                {
                    System.out.println("// " + o);
                }
            }*/
        }
        System.out.println("Yo2");
        //System.out.println(aMethod);

    }

    private static class MethodCall extends VoidVisitorAdapter<Void> {

        @Override
        public void visit(MethodCallExpr n, Void arg) {

            super.visit(n,arg);
            //System.out.println(n.getName());
        }
    }

    public void printContent()
    {
        System.out.println("/////////// start //////////");
        System.out.println(content);
    }

    private static void findMethodCallClass(CompilationUnit cu) {
        cu.findAll(MethodCallExpr.class).forEach(m -> { //for each method call
            System.out.println("Method Call: " + m);
            /*if(m.toString().equals("v.getVariables()"))
            {
                m.resolve();
                System.out.println("/Method Call: " + m + " " + m.resolve());
            }*/
            try {
                System.out.println("Class: " + m.resolve().getClass());
                System.out.println("Class: " + m.resolve().getPackageName() + "." + m.resolve().getClassName() + " for " + m); //check package name to identify Java libraries
            } catch (UnsolvedSymbolException e) {
                System.out.println("Method call unsolvable for " + m + "\n"); //for method calls made in lambda expr
                //unsolvable
            } catch (UnsupportedOperationException e) {
                System.out.println("wtf? " + e); //v.getVariables
            } catch (RuntimeException e) {
                System.out.println("y u do dis? " + e);
                System.out.println("For: " + m);
            }
            System.out.println();
        });
    }

    // does not include class fields
    private static void findVarType(CompilationUnit cu) {
        findVarTypeHelper(cu, VariableDeclarationExpr.class, "Declaration: ");
    }

    private static void findFieldVarType(CompilationUnit cu) {
        findVarTypeHelper(cu, FieldDeclaration.class, "Class Declaration: ");
    }

    // pass FieldDeclaration.class to find instance variables or VariableDeclarationExpr.class for local variables
    private static <T extends Node & NodeWithVariables<T>> void findVarTypeHelper(CompilationUnit cu, Class<T> cType, String printOut) {
        cu.findAll(cType).forEach(v -> { //for each expression
            System.out.println(printOut + v);
            //System.out.println(printOut + v.getVariables() + " " + v.getVariables().get(0).getType() + " " + v.getVariables().get(0).getType().getClass());
            v.getVariables().forEach(d -> { //for each declaration
                //System.out.print("Type: " + d.resolve().getType().asArrayType().getComponentType()); //arrays count as a different type
                try {
                    if (d.getType().isArrayType()) { //array types are also reference types so check it first
                        ResolvedType arrType = d.resolve().getType().asArrayType().getComponentType();
                        if (arrType.isReferenceType()) { //check in case it's an array of primitives
                            System.out.print(" (qualified name: " + arrType.asReferenceType().getQualifiedName() + ")"); //this also gets rid of the array part
                        }
                    } else if (d.getType().isReferenceType()) { //shouldn't be an array now
                        System.out.print(" (qualified name: " + d.resolve().getType().asReferenceType().getQualifiedName() + ")"); //qualified name includes both package and class name here
                    } else if (d.getType().getClass().toString().equals("class com.github.javaparser.ast.type.PrimitiveType"))
                    {
                        System.out.print(" (qualified name: " + d.resolve().getType().toString() + ")");
                    } else {
                        System.out.println("Leaving out: " + v);
                    }
                } catch (UnsolvedSymbolException e) {
                    System.out.print(printOut + " unsolvable for " + " " + v); //unsolvable
                } catch (UnsupportedOperationException e) {
                    System.out.print("\nfindVarTypeHelper wtf? " + printOut + " " + e);
                }
                System.out.println();
            });
            System.out.println();
        });
    }

    private static void findAllTypes(CompilationUnit cu) {
        /*
        ResolvedType rt = JavaParserFacade.get(typeSolver).convertToUsage(type);
        if (rt.isReferenceType()) {
            System.out.println(rt.asReferenceType().getQualifiedName());
        }
         */
        cu.findAll(Type.class).forEach(t -> {
            try { //basically same as the inner part of findVarTypeHelper, can deduplicate
                if (t.isArrayType()) { //array types are also reference types so check it first
                    ResolvedType arrType = t.resolve().asArrayType().getComponentType();
                    if (arrType.isReferenceType()) { //check in case it's an array of primitives
                        System.out.println(arrType.asReferenceType().getQualifiedName()); //this also gets rid of the array part
                    }
                } else if (t.isReferenceType()) { //shouldn't be an array now
                    System.out.println(t.resolve().asReferenceType().getQualifiedName()); //qualified name includes both package and class name here
                }
            } catch (UnsolvedSymbolException e) {
                System.out.println("Unsolvable: " + t);
            } catch (UnsupportedOperationException e) {
                System.out.println("\nwtf? " + e);
            }
        });
    }

    // assumes that all imports are used
    private static void findImports(CompilationUnit cu) {
        cu.findAll(ImportDeclaration.class).forEach(i -> {
            System.out.print(i.getName());
            if (i.isAsterisk()) {
                System.out.print(" (package)");
            }
            System.out.println();
        });
    }
}